/*
   Author: Zach Smith
   Model Name: 
   Status: DEVELOPMENTAL

    Simple maTLS record phase protocol.
    This handles a single message-response on a channel.
    Modification is handled only on the return trip for ease of modelling
    
        - Pairs of agents in the path symmetric keys
        - The content of the message is readable by all intermediate agents
        - Each intermediate agent decrypts using one shared symmetric key, re-encrypts with another

  We make the following assumptions

        - The handshake proceeded honestly 
            - We allow for corruption after the fact
            - The security claims within the handshake make this a safe assumption (by compositional security)
        - mac+senc is condensed to senc
        - A single middlebox can only appear once on each path

*/

theory matls_record

begin

builtins: symmetric-encryption
functions: keyedHash/2, hash/1

// ------------------------- Path Creation -------------------- //
/* These rules handle the establishment of a path. They act as a short-form of the
   handshake protocol. Intuitively, we want to show that the path chosen here will
   inevitably be the one that is used later
*/

// Initializes the client and adds a single middlebox
// Initiate looping lemmas
rule CreateClient:
    [
      // Encryption keys
      Fr(~k_acc_cs), // Will be used to define the path
      Fr(~k_acc_cm),
      Fr(~k_acc_ms), 
      Fr(~k_tls_cm)
    ]
  --[
      // Restrictions
      IsClient($A),
      IsMiddlebox($M),
      IsServer($S),
      UniqueOnPath($M, ~k_acc_cs),
      BindKeyToPath(~k_tls_cm, ~k_acc_cs),
      Bounded('add'),
      // Looping Helper Lemma
      LoopSource(~k_acc_cs),
      // Path Integrity Ordering
      PathOrder($C, $M, ~k_acc_cs)
    ]->
    [
      // Key registration
      !ClientSession($C, $M, $S, ~k_acc_cs, ~k_tls_cm), // Adjacent session (TLS)
      MiddleboxHalfSession($C, $M, 'empty', ~k_acc_cs, ~k_acc_cm, ~k_acc_ms, ~k_tls_cm, 'empty')
    ]

// Add a middlebox to the client's path
rule AddMiddlebox:
    [
      MiddleboxHalfSession(Last, $Current, 'empty', pathID, k_acc_cm1, k_acc_m1s, k_tls_last, 'empty'),
      Fr(~k_acc_m2s),
      Fr(~k_tls_next),
      Fr(~k_acc_cm2)
    ]
  --[
      // Restrictions
      IsMiddlebox($Next),
      UniqueOnPath($Next, pathID),
      BindKeyToPath(~k_tls_next, pathID),
      Bounded('add'),
      // Looping
      LoopStep(pathID),
      // Path Integrity
      PathOrder($Current, $Next, pathID),
      // Security
      RegisterHonestMiddlebox(pathID, $Current),
      RegisterAdjacentMiddleboxes(pathID, $Current, $Next)
    ]->
    [
      !MiddleboxSession(Last, $Current, $Next, pathID, k_acc_cm1, k_acc_m1s, k_tls_last, ~k_tls_next),
      !ClientAccountabilityKey($Current, pathID, k_acc_cm1),
      !ServerAccountabiltyKey($Current, pathID, k_acc_m1s),
      MiddleboxHalfSession($Current, $Next, 'empty', pathID, ~k_acc_cm2, ~k_acc_m2s, ~k_tls_next, 'empty')
    ]
// Add a corrupt middlebox (i.e. the adversary also learns the keys)

rule AddCorruptMiddlebox:
    [
      MiddleboxHalfSession(Last, $Current, 'empty', pathID, k_acc_cm1, k_acc_m1s, k_tls_last, 'empty'),
      Fr(~k_acc_m2s),
      Fr(~k_tls_next),
      Fr(~k_acc_cm2)
    ]
  --[
      // Restrictions
      IsMiddlebox($Next),
      UniqueOnPath($Next, pathID),
      BindKeyToPath(~k_tls_next, pathID),
      Bounded('add'),
      CorruptMiddlebox($Current, ~k_tls_next, pathID),
      CorruptMiddlebox($Current, k_tls_last, pathID),
      CorruptMiddleboxAccKey($Current, k_acc_cm1, pathID),
      CorruptMiddleboxAccKey($Current, k_acc_m1s, pathID),
      // Looping
      LoopStep(pathID),
      // Path Integrity
      PathOrder($Current, $Next, pathID),
      // Security
      RegisterAdjacentMiddleboxes(pathID, $Current, $Next)
    ]->
    [
      !MiddleboxSession(Last, $Current, $Next, pathID, k_acc_cm1, k_acc_m1s, k_tls_last, ~k_tls_next),
      !ClientAccountabilityKey($Current, pathID, k_acc_cm1),
      !ServerAccountabiltyKey($Current, pathID, k_acc_m1s),
      MiddleboxHalfSession($Current, $Next, 'empty', pathID, ~k_acc_cm2, ~k_acc_m2s, ~k_tls_next, 'empty')
    ]


// End a path by declaring the server
rule EndPath:
    [
      MiddleboxHalfSession(Last, $Current, 'empty', pathID, k_acc_cm1, k_acc_m1s, k_tls_last, 'empty'),
      Fr(~k_tls_next)
    ]
  --[ 
      // Restrictions
      IsServer($S),
      UniqueOnPath($S, pathID),
      SessionEstablished(pathID),
      BindKeyToPath(~k_tls_next, pathID),
      Bounded('add'),
      // Looping lemma
      LoopClose(pathID)
    ]->
    [
      !MiddleboxSession(Last, $Current, $S, pathID, k_acc_cm1, k_acc_m1s, k_tls_last, ~k_tls_next),
      !ClientAccountabilityKey($Current, pathID, k_acc_cm1),
      !ServerAccountabiltyKey($Current, pathID, k_acc_m1s),
      !ServerSession($C, $Current, $S, pathID, ~k_tls_next)
    ]


// ------------------------- Forward Path Operation -------------------- //
/* 
    The sending of messages, i.e. the main protocol rules.
*/

// Client sends a message. For this message, the pathID is precisely the accountability key
rule CreateRequest:
  let
    hashChain = keyedHash(hash(~request), pathID)
    outMsg = <'request', ~request, hashChain>
    outSenc = senc(outMsg, k_tls_cm)
  in
  [
    !ClientSession($C, $M, $S, pathID, k_tls_cm),
    Fr(~request)
  ]
--[
    // Restrictions
    RequireEstablishedSession(pathID),
    SendUsingKey(k_tls_cm, pathID),
    Bounded('req'),
    // Sources
    SentEncryptedUsing($C, outMsg, outSenc),    
    // Looping
    RequestSource(pathID, k_tls_cm, outMsg)
  ]->
  [
    Out(outSenc),
    ClientRequest(pathID, ~request)
  ]

// Middlebox forwards a request
rule ForwardRequest:
  let
    inMsg = <'request', request, inHashChain>
    inSenc = senc(inMsg, k_tls_cm1)
    outHashChain = keyedHash(inHashChain, k_acc_m1s)
    outMsg = <'request', request, outHashChain>
    outSenc = senc(outMsg, k_tls_m1m2)
  in
  [
    In(inSenc),
    !MiddleboxSession(Last, $M1, $M2, pathID, k_acc_cm1, k_acc_m1s, k_tls_cm1, k_tls_m1m2)
  ]
--[
    // Restrictions
    RequireEstablishedSession(pathID),
    RecvUsingKey(k_tls_cm1, pathID),
    SendUsingKey(k_tls_m1m2, pathID),
    Bounded('req'),
    UseAccKeyOnPath(k_acc_m1s, pathID),
    // Sources
    ReceivesEncryptedUsing($M1, inMsg, inSenc),
    SentEncryptedUsing($M1, outMsg, outSenc),
    // Looping
    RequestLoop(pathID, k_tls_cm1, inMsg)
  ]->
  [
    Out(outSenc)
  ]

// Server receives a request
// (they can unwrap it later)
rule ReceiveRequest:
  let
    inMsg = <'request', request, hashChain>
    inSenc = senc(inMsg, k_tls_ms)
  in
  [
    In(inSenc),
    !ServerSession($C, $Current, $S, pathID, k_tls_ms)
  ]
--[
    // Restrictions
    RequireEstablishedSession(pathID),
    RecvUsingKey(k_tls_ms, pathID),
    Bounded('req'),
    // Sources
    ReceivesEncryptedUsing($S, inMsg, inSenc),
    // Looping
    RequestRecv(pathID)
  ]->
  [
    ServerReceivesMessage($C, $Current, $S, pathID, request, hashChain)
  ]

rule ServerReply:
  let
    hashChain = keyedHash(hash(<'original', ~response>), pathID) // typeerrors
    outMsg = <'reply', ~response, hashChain>
    outSenc = senc(outMsg, k_tls_ms)
  in
  [
    Fr(~response),
    ServerReceivesMessage($C, $Current, $S, pathID, request, oldHashChain),
    !ServerSession($C, $Current, $S, pathID, k_tls_ms)
  ]
--[
    // Restrictions
    RequireEstablishedSession(pathID),
    SendUsingKey(k_tls_ms, pathID),
    Bounded('resp'),
    // Sources
    SentEncryptedUsing($S, outMsg, outSenc),
    // Looping
    ReplySource(pathID),
    // Security
    StartReplyOnPath(pathID, ~response)
  ]->
  [
    Out(outSenc)
  ]

// Middlebox forwards reply without modification
// Just hash the old hashchain, don't worry about it
rule ForwardReply_NoEdit:
  let
    inMsg = <'reply', response, inHashChain>
    inSenc = senc(inMsg, k_tls_m1m2)
    outHashChain = keyedHash(<'nochange', inHashChain>, k_acc_cm1) // avoid obvious typeerrors
    outMsg = <'reply', response, outHashChain>
    outSenc = senc(outMsg, k_tls_cm1)
  in
  [
    !MiddleboxSession($M2, $M1, Last, pathID, k_acc_cm1, k_acc_m1s, k_tls_cm1, k_tls_m1m2),
    In(inSenc)
  ]
--[
    // Restrictions
    RequireEstablishedSession(pathID),
    AlreadyReplied($M1, response),
    Bounded('resp'),
    RecvUsingKey(k_tls_cm1, pathID),
    SendUsingKey(k_tls_m1m2, pathID),
    UseAccKeyOnPath(k_acc_cm1, pathID),
    // Sources
    ReceivesEncryptedUsing($M1, inMsg, inSenc),
    SentEncryptedUsing($M1, outMsg, outSenc),
    // Looping
    ReplyLoop(pathID),
    // Security
    MiddleboxTransceives(pathID, $M, response, response),
    MiddleboxNoModify(pathID, $M)
  ]->
  [
    Out(outSenc)
  ]

rule ForwardReply_Edit:
  let
    inMsg = <'reply', response, inHashChain>
    inSenc = senc(inMsg, k_tls_m1m2)
    modificationLog = keyedHash(< 'change', hash(response), hash(~newResp) >, k_acc_cm1) 
    // we're including the hash of the ~old~ response, so that the receiver can unwrap it later (they can read the new response directly)
    outHashChain = < inHashChain, $M1, hash(response), modificationLog >
    outMsg = <'reply', ~newResp, outHashChain>
    outSenc = senc(outMsg, k_tls_cm1)
  in
  [
    !MiddleboxSession($M2, $M1, Last, pathID, k_acc_cm1, k_acc_m1s, k_tls_cm1, k_tls_m1m2),
    In(inSenc),
    Fr(~newResp)
  ]
--[
    // Restrictions
    RequireEstablishedSession(pathID),
    AlreadyReplied($M1, response),
    Bounded('resp'),
    SendUsingKey(k_tls_cm1, pathID),
    RecvUsingKey(k_tls_m1m2, pathID),
    UseAccKeyOnPath(k_acc_cm1, pathID),
    // Sources
    ReceivesEncryptedUsing($M1, inMsg, inSenc),
    SentEncryptedUsing($M1, outMsg, outSenc),
    // Looping
    ReplyLoop(pathID),
    // Security
    MiddleboxModifies(pathID, $M, response, ~newResp),
    MiddleboxTransceives(pathID, $M, response, ~newResp)
  ]->
  [
    Out(outSenc)
  ]

// Client receives a reply. We can unwrap it later
rule ReceiveReply:
  let
    inMsg = <'reply', response, inHashChain>
    inSenc = senc(inMsg, k_tls_cm1)
  in
  [
    !ClientSession($C, $M, $S, pathID, k_tls_cm1),
    In(inSenc),
    ClientRequest(pathID, request)
  ]
--[
    // Sources
    ReceivesEncryptedUsing($C, inMsg, inSenc),
    // Restrictions
    Bounded('resp'),
    RecvUsingKey(k_tls_cm1, pathID),
    // Looping
    ReplyRecv(pathID),
    // Security
    ReceiveReplyOnPath(pathID)
  ]->
  [
    CheckReply(pathID, request, response, inHashChain)
  ]


// Unwrap a step of the reply
// Not the server, and no modification
rule UnwrapReplyNoModification:
  let
    inHashChain = keyedHash(<'nochange', outHashChain>, k_acc_cm1)
    newResponse = response // the message didn't change
  in
  [
    CheckReply(pathID, request, response, inHashChain),
    !ClientSession($C, $M, $S, pathID, k_tls_cm1),
    !ClientAccountabilityKey($Current, pathID, k_acc_cm1)
  ]
--[
    // Restrictions
    Bounded('unwrap'),
    // Security
    ObserveMiddleboxOnPath(pathID, $M),
    ObserveMiddleboxNoModifiesOnPath(pathID, $M)
  ]->
  [
    CheckReply(pathID, request, newResponse, outHashChain)
  ]


// Unwrap a step of the reply
// Not the server, and with modification
rule UnwrapReplyModification:
  let
    newResponse = response // the message didn't change
    // the middlebox changed it from new to resp, but we're working backwards!
    modificationLog = keyedHash(<'change', hash(newResponse), hash(response)>, k_acc_cm1)
    inHashChain = < outHashChain, $Current, hash(response), modificationLog >
  in
  [
    CheckReply(pathID, request, response, inHashChain),
    !ClientSession($C, $M, $S, pathID, k_tls_cm1),
    !ClientAccountabilityKey($Current, pathID, k_acc_cm1)
  ]
--[
    // Restrictions
    Bounded('unwrap'),
    // Security
    ObserveMiddleboxOnPath(pathID, $M),
    ObserveMiddleboxModifiesOnPath(pathID, $M, response, newResponse)
  ]->
  [
    CheckReply(pathID, request, newResponse, outHashChain)
  ]

// Unwrap a step of the reply
// The original server message
rule UnwrapReplyServer:
  let
    // the middlebox changed it from new to resp, but we're working backwards!
    inHashChain = keyedHash(hash(<'original', response>), pathID)
  in
  [
    CheckReply(pathID, request, response, inHashChain),
    !ClientSession($C, $M, $S, pathID, k_tls_cm1)
  ]
--[
    // Restrictions
    Bounded('unwrap'),
    // Check
    Reachable(),
    // Security
    ConfirmReplyOnPath(pathID, response)
  ]->
  [
  ]


// ------------------------- Restrictions --------------------- //

// If someone is a client, they are not a middlebox or a server etc. 
restriction unique_role:
"
    (All A #tc. IsClient(A)@tc ==> not Ex #tm. IsMiddlebox(A)@tm)
  & (All A #tc. IsClient(A)@tc ==> not Ex #ts. IsServer(A)@ts)
  & (All A #tm. IsMiddlebox(A)@tm ==> not Ex #tc. IsClient(A)@tc)
  & (All A #tm. IsMiddlebox(A)@tm ==> not Ex #ts. IsServer(A)@ts)
  & (All A #ts. IsServer(A)@ts ==> not Ex #tc. IsClient(A)@tc)
  & (All A #ts. IsServer(A)@ts ==> not Ex #tm. IsMiddlebox(A)@tm)
"

// A given middlebox can only be on each path once
restriction unique_on_path:
"
  All A pID #t1 #t2. UniqueOnPath(A, pID)@t1 & UniqueOnPath(A, pID)@t2
    ==> (#t1 = #t2)
"

// A middlebox won't wilingly edit the same response twice (i.e. in a replay)
restriction already_replied:
"
  All response agent #tresp1 #tresp2. AlreadyReplied(agent, response)@tresp1 &
        AlreadyReplied(agent, response)@tresp2
  ==> (#tresp1 = #tresp2)
"

// Bound the length of paths
restriction bounded:
"
  All type #t1 #t2 #t3 #t4.
    Bounded(type)@t1 & Bounded(type)@t2 & Bounded(type)@t3 & Bounded(type)@t4
  ==>
    (#t1 = #t2)|(#t1 = #t3)|(#t1 = #t4)|
    (#t2 = #t3)|(#t2 = #t4)|
    (#t3 = #t4)
"

// If an agent sends using a key, then either the value is secret or the sender is corrupt
// Follows as keys cannot be derived from messages
restriction send_tls_keys:
"
  All tlsKey pathID #tuse. SendUsingKey(tlsKey, pathID)@tuse
==>
  ((not Ex #tkk. KU(tlsKey)@tkk) &
  (not Ex #tkp. KU(pathID)@tkp)
  )
"

// If an agent receives using a key, then either the value is secret, they are corrupt,
// or their predecessor is corrupt
restriction recv_tls_keys:
"
  All tlsKey pathID #tuse. RecvUsingKey(tlsKey, pathID)@tuse
==>
  ((not Ex #tkk. KU(tlsKey)@tkk) &
  (not Ex #tkp. KU(pathID)@tkp)
  ) 
"

restriction unknown_acc_keys:
"
  All accKey pathID #tuse. UseAccKeyOnPath(accKey, pathID)@tuse
==>
  (not Ex #tkk. KU(accKey)@tkk) &
  (not Ex #tkp. KU(pathID)@tkp)
//  ) | (
//  Ex M #tcorrupt. CorruptMiddleboxAccKey(M, accKey, pathID)@tcorrupt
//  )
"

// ----------------------------- Looping ------------------------- //

lemma PathCreationLoop[use_induction, reuse]:
"
  (All pID #tloop. LoopStep(pID)@tloop
==>
  Ex #tsource. LoopSource(pID)@tsource) &
   (All pID #tclose. LoopClose(pID)@tclose
==>
  Ex #tsource. LoopSource(pID)@tsource)  
"
// ------------------------- Reachability --------------------- //

lemma reachable:
  exists-trace
"
  Ex #t. Reachable()@t
"

// ----------------------- Security/Helper ------------------- //

// If an agent is added to a path (and they are not corrupt),
// and the client confirms a response, then that agent acted
// during the loop.
// This is a helper lemma: it establishes a bijection for modification integrity
lemma AlwaysActOnPath:
  all-traces
  "
    All M pathID reply #tadd #tstart #tconfirm.
        RegisterHonestMiddlebox(pathID, M)@tadd &
        StartReplyOnPath(pathID, reply)@tstart &
        ConfirmReplyOnPath(pathID, reply)@tconfirm & // (client can read the reply from the mod.log)
        (#tadd < #tstart) &
        (#tstart < #tconfirm)
    ==> // the middlebox either modified the message, or didn't
    (
      Ex from to #tmod. 
          MiddleboxModifies(pathID, M, from, to)@tmod &
          (#tstart < #tmod) &
          (#tmod < #tconfirm)
    )|(
      Ex #tnomod.
          MiddleboxNoModify(pathID, M)@tnomod &
          (#tstart < #tnomod) &
          (#tnomod < #tconfirm)
    )
  "

// Another helper for modification/path integrity.
// The previous lemma states that every (honest) middlebox does indeed act.
// Now we show the opposite: that the client will always observe an action by
// each middlebox. This does not guarantee that the middlebox actually acted
// (only that the client believes that they did)
lemma AlwaysObserveActions:
  all-traces
  "
    All M pathID reply #tadd #trecv #tconfirm.
      RegisterHonestMiddlebox(pathID, M)@tadd &
      ReceiveReplyOnPath(pathID)@trecv &
      ConfirmReplyOnPath(pathID, reply)@tconfirm
    ==>
    Ex #tobserve.
      ObserveMiddleboxOnPath(pathID, M)@tobserve &
      (#trecv < #tobserve) &
      (#tobserve < #tconfirm)
  "

// ----------------------- Security/Goals ------------------- //

// The client always has an "idea" of what the server initially intended to send
// Importantly, this means that the server did indeed determine a reply at some point,
// and it's not the case that one of the middleboxes is secretly behaving as an endpoint
lemma DataAuthentication:
  all-traces
  "
    All pathID reply #tconfirm.
        ConfirmReplyOnPath(pathID, reply)@tconfirm
    ==>
    Ex #treply. StartReplyOnPath(pathID, reply)@treply
  "

// The client can detect whether or not an (honest) middlebox has modified a reply in-transit
// We confirmed in previous lemmas that these middleboxes always act, and that we always
// observe that an action took place. Now we are confirming that the action is indeed what
// we thought it was
lemma ModificationAccountability:
  all-traces
  "
  All pathID M reply #tadd #tconfirm #trecv.
      RegisterHonestMiddlebox(pathID, M)@tadd &
      ReceiveReplyOnPath(pathID)@trecv &
      ConfirmReplyOnPath(pathID, reply)@tconfirm
  ==>
    ( // Modification
      All from to #tobs.
        ObserveMiddleboxModifiesOnPath(pathID, M, from, to)@tobs
      ==>
      Ex #tmod.
        MiddleboxModifies(pathID, M, from, to)@tmod
    ) & ( // No Modification
      All #tobs.
        ObserveMiddleboxNoModifiesOnPath(pathID, M)@tobs
      ==>
      Ex #tnomod.
        MiddleboxNoModify(pathID, M)@tnomod 
    )
  "

// The order in which the client added middleboxes is consistent with the
// order in which the middleboxes actually act.
// This works in reverse order for replies
// We only consider adjacent middleboxes, and the full path follows by trivial induction
lemma PathIntegrity:
  all-traces
  "
  All pathID M1 M2 reply #tadd1 #tadd2 #tadjacent #tconfirm #trecv.
      RegisterHonestMiddlebox(pathID, M1)@tadd1 &
      RegisterHonestMiddlebox(pathID, M2)@tadd2 &
      RegisterAdjacentMiddleboxes(pathID, M1, M2)@tadjacent &
      ReceiveReplyOnPath(pathID)@trecv &
      ConfirmReplyOnPath(pathID, reply)@tconfirm
  ==>
  // If M1 touched the message "in", then M2 created the message "in"
  (
    All current new #tm1.
      MiddleboxTransceives(pathID, M1, current, new)@tm1
    ==>
    Ex old #tm2.
      MiddleboxTransceives(pathID, M2, old, current)@tm2 &
      (#tm2 < #tm1)
  )
  "
end